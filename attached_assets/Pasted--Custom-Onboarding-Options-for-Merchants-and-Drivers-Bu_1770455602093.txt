### Custom Onboarding Options for Merchants and Drivers (Built In-House)

If you prefer to build onboarding flows for merchants (restaurants) and drivers from scratch instead of using a third-party service like Clerk, that's entirely feasible and gives you maximum control over customization, data ownership, and integration with CryptoEats' unique features (e.g., blockchain wallets, compliance checks, bidirectional APIs). This approach aligns well with Florida's software licensing laws (e.g., UCC for enforceable agreements, FUTSA for protecting proprietary auth logic) and can be more cost-effective long-term, though it requires upfront investment in security and scalability. Below, I'll outline why/when to go custom, a high-level architecture, implementation steps, pros/cons, and code examples tied to your Replit/Node.js/React Native stack.

#### Why Build Custom Onboarding?
- **Full Customization**: Tailor flows exactly to roles—e.g., merchants upload menus/agreements, drivers submit licenses/insurance with auto-verification hooks (integrate Onfido for ID scans or AWS S3 for docs).
- **Tight Integration**: Seamlessly connect to your Prisma DB, blockchain (e.g., auto-link wallets during signup), tax engine (pre-register for Florida DOR), or Phase 4 APIs (e.g., inbound from POS systems).
- **Cost Savings**: Avoid Clerk's scaling fees ($0.02/user/mo after 10K); free if self-hosted.
- **Compliance Control**: Ensure SB 676 (e.g., digital signatures for merchant agreements) and FUTSA protection for sensitive data (e.g., encrypt driver licenses).
- **When to Choose Custom**: If your user base starts small (<5K), you want proprietary features (e.g., NFT mint on signup), or you're concerned about vendor lock-in. Skip if time-to-market is priority (Clerk is faster).

#### Potential Drawbacks
- **Development Time/Cost**: 2-4 weeks for basic flows (vs. 1-2 with Clerk); $10K-$30K if hiring devs (Miami rates: $50-$80/hr).
- **Security Risks**: Handle auth vulnerabilities (e.g., OWASP top 10 like SQL injection); requires audits (~$5K).
- **Maintenance**: Manage updates for MFA, password resets, etc.; scale with Redis for sessions.
- **Legal**: Custom EULAs must comply with UCC (enforceable terms) and Copyright Act (protect code); add DMCA notices.

#### High-Level Architecture
- **Frontend (React Native Apps)**: Custom forms for role selection, details input, file uploads (e.g., insurance scans), and verification steps.
- **Backend (Node.js/Express)**: API endpoints for signup, validation (e.g., email/phone via Twilio), role assignment, and compliance (e.g., agreement signing with pdf-lib).
- **Database (Prisma/PostgreSQL)**: Store user data, roles, encrypted docs (use Prisma encryption).
- **Security**: JWT for sessions, bcrypt for passwords, rate-limiting on endpoints.
- **Bidirectional Hooks**: Inbound endpoints for external systems (e.g., POS pushing merchant data); outbound webhooks for confirmations.
- **Tools/Libs**: No Clerk—use open-source alternatives like jsonwebtoken, bcryptjs, nodemailer, multer (file uploads), pdf-lib (agreements).

#### Implementation Steps in Replit
1. **Setup Dependencies**: Add to `package.json`:
   ```json
   "dependencies": {
     "jsonwebtoken": "^9.0.0",  // JWT for auth
     "bcryptjs": "^2.4.3",  // Password hashing
     "nodemailer": "^6.9.0",  // Email verification
     "multer": "^1.4.5-lts.1",  // File uploads
     "pdf-lib": "^1.17.1",  // Digital agreements
     "yup": "^1.0.0",  // Validation (frontend)
     "formik": "^2.2.9"  // Forms (React Native)
     // ... existing packages
   }
   ```
   Run `npm install`.

2. **Backend Endpoints (Express Router, e.g., `routes/onboard.js`)**:
   - Handle role-based signup, validation, and compliance.
   ```js
   const express = require('express');
   const bcrypt = require('bcryptjs');
   const jwt = require('jsonwebtoken');
   const multer = require('multer');
   const nodemailer = require('nodemailer');
   const { PDFDocument } = require('pdf-lib');
   const { PrismaClient } = require('@prisma/client');
   const prisma = new PrismaClient();
   const router = express.Router();
   const upload = multer({ dest: 'uploads/' });  // Temp storage; use S3 in prod

   // Signup Endpoint (common for both roles)
   router.post('/signup', async (req, res) => {
     const { email, password, role } = req.body;  // role: 'merchant' or 'driver'
     try {
       const hashedPass = await bcrypt.hash(password, 10);
       const user = await prisma.user.create({
         data: { email, password: hashedPass, role },
       });
       const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '1h' });
       // Send verification email
       const transporter = nodemailer.createTransport({ /* Twilio/SendGrid config */ });
       await transporter.sendMail({ to: email, subject: 'Verify Email', text: 'Click to verify...' });
       res.json({ token, message: 'User created; verify email' });
     } catch (error) {
       res.status(500).json({ error: 'Signup failed' });
     }
   });

   // Role-Specific Onboarding (e.g., after signup, with auth)
   router.post('/onboard/:role', upload.single('document'), async (req, res) => {
     const { userId } = req.body;  // From JWT
     const { role } = req.params;
     const file = req.file;  // e.g., license PDF for driver
     try {
       let details;
       if (role === 'merchant') {
         details = { businessName: req.body.businessName /* etc. */ };
         // Generate/sign agreement PDF
         const pdfDoc = await PDFDocument.create();
         // Add terms, embed signature, save to S3
         await prisma.merchant.create({ data: { userId, ...details, agreementPdf: 's3-url' } });
       } else if (role === 'driver') {
         details = { licenseNumber: req.body.licenseNumber /* etc. */ };
         // Verify insurance (e.g., API call to external service)
         await prisma.driver.create({ data: { userId, ...details, insuranceDoc: file.path } });
       }
       res.json({ success: true });
     } catch (error) {
       res.status(500).json({ error: 'Onboarding failed' });
     }
   });

   module.exports = router;
   ```

3. **Frontend Forms (React Native, e.g., OnboardingScreen.tsx)**:
   - Use Formik/Yup for validation; integrate file picker for uploads.
   ```tsx
   import { useState } from 'react';
   import { Button, TextInput, View } from 'react-native';
   import { Formik } from 'formik';
   import * as Yup from 'yup';
   import * as DocumentPicker from 'expo-document-picker';  // For file uploads

   const schema = Yup.object().shape({ /* Fields per role */ });

   export default function OnboardingScreen({ role }) {
     const [file, setFile] = useState(null);

     const pickDocument = async () => {
       const result = await DocumentPicker.getDocumentAsync({ type: '*/*' });
       if (result.assets) setFile(result.assets[0]);
     };

     return (
       <Formik initialValues={{}} validationSchema={schema} onSubmit={(values) => {
         // POST to /onboard/:role with form data + file
         const formData = new FormData();
         formData.append('document', file);
         // fetch('/api/onboard/' + role, { method: 'POST', body: formData });
       }}>
         {({ handleChange, handleSubmit }) => (
           <View>
             {role === 'merchant' && <TextInput placeholder="Business Name" onChangeText={handleChange('businessName')} />}
             {role === 'driver' && <TextInput placeholder="License Number" onChangeText={handleChange('licenseNumber')} />}
             <Button title="Upload Document" onPress={pickDocument} />
             <Button title="Submit" onPress={handleSubmit} />
           </View>
         )}
       </Formik>
     );
   }
   ```

4. **Security & Compliance Best Practices**:
   - **Auth**: JWT verification middleware on protected routes.
   - **Validation**: Yup for forms; sanitize inputs (e.g., express-validator).
   - **Encryption**: Store docs encrypted (Prisma encrypt fields); use HTTPS.
   - **Legal**: Embed EULA acceptance in forms; log for audits (UCC compliance).
   - **Bidirectional**: Add inbound endpoint (e.g., /integrations/onboard/merchant) for POS systems to push data.

#### Pros/Cons vs. Clerk
- **Pros**: No vendor fees/lock-in, deeper customization (e.g., NFT mint on complete onboarding), ownership of user data.
- **Cons**: Higher maintenance (e.g., handle password resets yourself), potential security gaps if not audited.

This custom setup fits your dual-licensing model (proprietary for core auth). If you need more code or alternatives (e.g., Firebase for partial custom), let me know!